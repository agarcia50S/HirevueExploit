import requests, re, json
from urllib.parse import urlparse

# -----Scrape by Request-----

# Utility Functions
def format_cookie(cookie_seq):
    '''
    Takes sequence of cookies (e.g. name1=value1; name2=value2; ...; nameX=valueX)
    and formats them into a structure that works with selenium 
    (i.e. [{'name':name1, 'value':value1}, {'name':name2, 'value':value2}] )
    '''
    cookie_pairs = cookie_seq.split(';')

    # list of dicts where values are cookie name and cookie value, respectively
    formatted = [{'name': pair.strip().split('=')[0], 'value':pair.strip().split('=')[1]} for pair in cookie_pairs]
    return formatted

def format_headers(raw_headers):
    '''
    Takes raw
    '''

    all_headers = {
        "auth": "",
        "cookie": "",
        "others": {}
    }

    # remove all whitespace then split on newlines
    header_pairs = re.sub(r'/[^\S\r\n]/', '', raw_headers.strip()).split('\n')
    
    for pair in header_pairs:
        split_pair = pair.lower().split(': ')

        if "authorization" in split_pair:
            token_type, token_value = split_pair[1].split(' ')
            all_headers['auth'] = (token_type, token_value)

        elif "cookie" in split_pair: all_headers['cookies'] = format_cookie(split_pair[1])

        else: all_headers['others'][split_pair[0]] = split_pair[1]

    return all_headers

def make_url(url):
    '''
    Takes interview URL and uses it to create URL where JSON file is stored
    '''
    parsed = urlparse(url)
    interview_code = parsed.path.split('/')[2]
    api_url = f"https://{parsed.netloc}/api/internal/candidates/interviews/{interview_code}/?future-practice-questions&include=answers,reuses,sections,poc&_="
    return api_url

# GET request Function
def get_json(url, auth_token=('', ''), req_headers=None, req_cookies=None):
    # authorization header: scheme is Bearer token
    response = requests.get(url, auth=auth_token, headers=req_headers, cookies=req_cookies)
    try:
        return response.json()
    except json.JSONDecodeError:
        print(f"Response to GET request:\n\n{response.content}\n\nExpected Reponse: a JSON string")

# -------Parse, Clean and Display--------

def seconds_to_minutes(sec):
    minutes = sec // 60
    remainder = sec % 60
    if remainder == 0:
        return f"{minutes} {'minutes' if minutes > 1 else 'minute'}"
    else:
        return f"{minutes} {'minutes' if minutes > 1 else 'minute'} and {remainder} {'sec' if sec > 1 else 'second'}"

def unscramble_all(question_container, key):
    for container in question_container:
        first_half = container[key][:len(container[key])//2]

        second_half = container[key][len(container[key])//2:]
        result = [second_half[i] + first_half[i] for i in range(len(first_half))]

        if len(container[key]) % 2 == 1: result.append(second_half[-1])
        container[key] = "".join(result)

def prepare_questions(json_obj, encoded=False):
    questions = unscramble_all(json_obj['questions'], 'text') if encoded else json_obj['questions']

    est_time_msg = f"Estimated Completion Time: {json_obj['estimatedMinutesToComplete']}"
    max_time_msg = f"Max Completion Time: {seconds_to_minutes(sum(q['maxDuration'] for q in questions))}"      
    total_qs_msg = f"Total Questions: {json_obj['questionCount']}"

    overview_msg = f"Interview Overview:\n{est_time_msg}\n{max_time_msg}\n{total_qs_msg}"

    export_msgs = [overview_msg]

    for q in questions:
        q_text = q['text'].replace('\t', ' ')
        talk_time_msg = f"Max time to response: {seconds_to_minutes(q['maxDuration'])}"
        prep_time_msg = f"Max time to prepare: {seconds_to_minutes(q['prepTimeSeconds'])}"
        num_attemps_msg = f"Number of attemps: {q['attemptsAvailable']}"

        combined_msg = f"{q_text}\n{talk_time_msg}\n{prep_time_msg}\n{num_attemps_msg}"

        export_msgs.append(combined_msg)
    return export_msgs

def display(texts):
    for one_text in texts:
        print(one_text, end='\n\n')
# ------For Testing--------
def retrieve_local_json(path):
    with open(path, mode='r') as file:
        return json.load(file)
    
# ------Storage-----
def save_interview_details(out_path, texts):
    with open(out_path, mode='w') as file:
        file.writelines(texts)
if __name__ == "__main__":
    usage_msg = '''
[Command format: python view_questions.py INTERVIEW LINK]
[-e, --encrypted: Pass alone when questions are encrypted]
[-s, --save: Use to save questions at given path in a text]
['-a', --auth: Pass with value to add authorization header to GET requestion]
'''

    parser = argparse.ArgumentParser(description='The program requests access to your interview question and presents them to you',
                                    epilog='For more help see the documentation at https://github.com/agarcia50S/HirevueExploit',
                                    usage=usage_msg)
