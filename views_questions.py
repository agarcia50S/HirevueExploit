import requests
import re
import json

def format_cookie(cookie_seq):
    '''
    Takes sequence of cookies (e.g. name1=value1; name2=value2; ...; nameX=valueX)
    and formats them into a structure that works with selenium 
    (i.e. [{'name':name1, 'value':value1}, {'name':name2, 'value':value2}] )
    '''
    cookie_pairs = cookie_seq.split(';')

    # list of dicts where values are cookie name and cookie value, respectively
    formatted = [{'name': pair.strip().split('=')[0], 'value':pair.strip().split('=')[1]} for pair in cookie_pairs]
    return formatted

def format_headers(raw_headers):
    '''
    Takes raw
    '''

    all_headers = {
        "auth": "",
        "cookie": "",
        "others": {}
    }

    # remove all whitespace then split on newlines
    header_pairs = re.sub(r'/[^\S\r\n]/', '', raw_headers.strip()).split('\n')
    
    for pair in header_pairs:
        split_pair = pair.lower().split(': ')

        if "authorization" in split_pair:
            token_type, token_value = split_pair[1].split(' ')
            all_headers['auth'] = (token_type, token_value)

        elif "cookie" in split_pair: all_headers['cookies'] = format_cookie(split_pair[1])

        else: all_headers['others'][split_pair[0]] = split_pair[1]

    return all_headers

def get_json(url, auth_token, req_headers=None, req_cookies=None):
    # authorization header: scheme is Bearer token
    response = requests.get(url, auth=auth_token, headers=req_headers, cookies=req_cookies)
    return response.json()

def save_interview_details(out_path, json_obj):
    with open(out_path, mode='wb') as file:
        file.write()

def seconds_to_minutes(sec):
    minutes = sec // 60
    remainder = sec % 60
    if remainder == 0:
        return f"{minutes} {'minutes' if minutes > 1 else 'minute'}"
    else:
        return f"{minutes} {'minutes' if minutes > 1 else 'minute'} and {remainder} {'sec' if sec > 1 else 'second'}"

def view_interview_details(json_obj, encoded=False):
    questions = json_obj['questions']
    if encoded:
        for q in questions:
            q['text'] = unscramble(q['text'])

    est_time = json_obj['estimatedMinutesToComplete']
    max_time = seconds_to_minutes(sum(q['maxDuration'] for q in questions)  )      

    opening_msg = f'''
Based on Hirevue's analytics it should take about {est_time} to complete the 
interview. The maxium amount of time the interview will take is {max_time}. 
The interview will be composed of the following {len(questions)} questions.
'''

    print(opening_msg)

    for q in questions:
        q_text = q['text'].replace('\t', ' ')
        talk_time_msg = f"Max time to response: {seconds_to_minutes(q['maxDuration'])}"
        prep_time_msg = f"Max time to prepare: {seconds_to_minutes(q['prepTimeSeconds'])}"
        num_attemps_msg = f"Number of attemps: {q['attemptsAvailable']}"

        combined_msg = f"{q_text}\n{talk_time_msg}\n{prep_time_msg}\n{num_attemps_msg}"
        print(combined_msg)        


def unscramble(ciphertext):
    first_half = ciphertext[:len(ciphertext)//2]

    second_half = ciphertext[len(ciphertext)//2:]
    result = []

    for i in range(0, len(first_half)):
        result.append(second_half[i])
        result.append(first_half[i])

    if(len(ciphertext) % 2 == 1):
        result.append(second_half[-1])

    return "".join(result)

if __name__ == "__main__":
    path = "C:/Users/agarc/RandomScripts/data/interview_data.json"
    with open(path, mode='r') as file:
        data = json.load(file)

    view_interview_details(data)
